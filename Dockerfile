FROM python:3.9-slim
WORKDIR /app
        #  Це ми вказали робочу директорію всередині контейнера.
        #  Значить для Flask-у створюється в самому контейнері директорія /app,
        #  в яку закладаються всі файли нашого додатку.
        #  Всі наступні команди будуть виконуватись відносно цієї директорії.
        #  Якщо такої директорії немає, Docker її створить.
COPY requirements.txt .
        #  Це ми скопіювали файл requirements.txt з нашої локальної машини в контейнер.
        #  Копіювання відбувається в робочу директорію, яку ми вказали вище.
        #  Ця крапка в кінці цієї інструкції  означає що файл requirements.txt 
        #  повинен знаходитись в кореневій директорії самого проекту.
        #  Тобто в контейнері тепер буде файл /app/requirements.txt
RUN pip install --no-cashe-dir -r requirements.txt
        #  Тобто не створювати в кеш пам'яті  копії директорії.
        #  Ключ --no-cache-dir означає що pip не буде зберігати кеш завантажених пакетів.
        #  Тобто для процесу інсталяції пакетів  кеш не буде використовуватись.
        #  Це зменшить розмір контейнера.
        #  -r трактується як "read" (прочитати) і вказує pip що потрібно
        #  прочитати всі залежності із файлу requirements.txt.
        #  Це - інструкція запустити встановлення всіх модулів-бібліотек, 
        #  які перелічені в файлі requirements.txt.
        #  Після виконання цієї інструкції в контейнері будуть встановлені всі 
        #  необхідні бібліотеки для роботи нашого Flask-додатку.
COPY . .
        #  Це інструкція скопіювати всі файли і папки з нашої локальної машини 
        #  в кореневу директорію образа.
        #  Копіювання відбувається в робочу директорію, яку ми вказали вище - 
        #  тобто в папку /app.
        #  Ця крапка в кінці цієї інструкції означає що всі файли і папки 
        #  повинні знаходитись в кореневій директорії самого проекту.
        #  Тобто в контейнері тепер будуть всі файли і папки нашого проекту.
EXPOSE 80
        #  Це інструкція вказати Docker що контейнер буде слухати 
        #  вхідні запити на вказаному порту.
        #  EXPOSE задає той порт, який буде слухатись ззовні, 
        #  тобто порт на якому додаток буде доступний зовні контейнера - 
        #  для зовнішніх підключень.
        #  В нашому випадку це порт 80.
        #  Це не означає що порт буде відкритий зовні, 
        #  це просто декларація що додаток всередині контейнера 
        #  буде слухати цей порт.
        #  Отже всередині Docker-а для нашого додатку  може теоретично 
        #  працювати один порт, а ззовні інший порт. Але краще щоб вони співпадали, 
        #  тому що тоді менше ризику переплутати зовнішній і внутрішній порти.
        #  Щоб зробити порт доступним зовні, потрібно буде 
        #  при запуску контейнера вказати мапінг портів.
        #  Наприклад, щоб пробросити порт 80 контейнера на порт 8080 хоста,
        #  потрібно буде при запуску контейнера додати параметр -p 8080:80 
CMD ["python", "app.py"]
        #  Це інструкція яка вказує Docker яку команду потрібно виконати 
        #  коли контейнер буде запущений.
        #  CMD задає команду яка буде виконана при старті контейнера.
        #  Як правило - це список назв програм і їх аргументів.
        #  В нашому випадку це команда запуску Flask-додатку.
        #  Ми вказали що потрібно виконати інтерпретатор python 
        #  з аргументом app.py - це означає що потрібно запустити файл app.py 
        #  за допомогою інтерпретатора python.
        #  Важливо щоб цей файл (app.py) був скопійований в контейнер 
        #  на попередньому кроці (COPY . .), інакше команда не спрацює.
        #  CMD повинен бути останньою інструкцією в Dockerfile, 
        #  тому що якщо буде ще якась інструкція після CMD, 
        #  то вона перезапише CMD і контейнер не запуститься як треба.
